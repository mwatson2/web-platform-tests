<!DOCTYPE html>
<meta charset=utf-8>
<title>KeyframeEffectReadOnly constructor tests</title>
<link rel="help" href="https://w3c.github.io/web-animations/#processing-a-keyframes-argument">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="../../testcommon.js"></script>
<body>
<div id="log"></div>
<div id="target"></div>
<script>
'use strict';

// Test the "process a keyframe-like object" procedure.
//
// This file only tests the KeyframeEffectReadOnly constructor since it is
// assumed that the implementation of the KeyframeEffect constructor,
// Animatable.animate() method, and KeyframeEffect.setKeyframes() method will
// all share common machinery and it is not necessary to test each method.

// Test that only animatable properties are accessed

var gNonAnimatableProps = [
  'animation', // Shorthands where all the longhand sub-properties are not
               // animatable, are also not animatable.
  'animationDelay',
  'animationDirection',
  'animationDuration',
  'animationFillMode',
  'animationIterationCount',
  'animationName',
  'animationPlayState',
  'animationTimingFunction',
  'transition',
  'transitionDelay',
  'transitionDuration',
  'transitionProperty',
  'transitionTimingFunction',
  'display',
  'unsupportedProperty',
];

function TestKeyframe(testProp) {
  var _propAccessCount = 0;

  Object.defineProperty(this, testProp, {
    get: function() { _propAccessCount++; },
    enumerable: true
  });

  Object.defineProperty(this, 'propAccessCount', {
    get: function() { return _propAccessCount; }
  });
}

function GetTestKeyframeSequence(testProp) {
  return [ new TestKeyframe(testProp) ]
}

gNonAnimatableProps.forEach(function(prop) {
  test(function(t) {
    var testKeyframe = new TestKeyframe(prop);

    new KeyframeEffectReadOnly(null, testKeyframe);

    assert_equals(testKeyframe.propAccessCount, 0, 'Accessor not called');
  }, 'non-animatable property \'' + prop + '\' is not accessed when using'
     + ' a property-indexed keyframe object');
});

gNonAnimatableProps.forEach(function(prop) {
  test(function(t) {
    var testKeyframes = GetTestKeyframeSequence(prop);

    new KeyframeEffectReadOnly(null, testKeyframes);

    assert_equals(testKeyframes[0].propAccessCount, 0, 'Accessor not called');
  }, 'non-animatable property \'' + prop + '\' is not accessed when using'
     + ' a keyframe sequence');
});

// Test equivalent forms of property indexed and sequenced keyframe syntax

function assertEquivalentKeyframeSyntax(keyframesA, keyframesB) {
  var processedKeyframesA = new KeyframeEffectReadOnly(null, keyframesA).getKeyframes();
  var processedKeyframesB = new KeyframeEffectReadOnly(null, keyframesB).getKeyframes();
  assert_frame_lists_equal(processedKeyframesA, processedKeyframesB);
}

var gEquivalentSyntaxTests = [
  {
    description: 'two properties with one value',
    indexedKeyframes: {
      left: '100px',
      opacity: ['1'],
    },
    sequencedKeyframes: [
      {left: '100px', opacity: '1'},
    ],
  },
  {
    description: 'two properties with three values',
    indexedKeyframes: {
      left: ['10px', '100px', '150px'],
      opacity: ['1', '0', '1'],
    },
    sequencedKeyframes: [
      {left: '10px', opacity: '1'},
      {left: '100px', opacity: '0'},
      {left: '150px', opacity: '1'},
    ],
  },
  {
    description: 'two properties with different numbers of values',
    indexedKeyframes: {
      left: ['0px', '100px', '200px'],
      opacity: ['0', '1']
    },
    sequencedKeyframes: [
      {left: '0px', opacity: '0'},
      {left: '100px'},
      {left: '200px', opacity: '1'},
    ],
  },
  {
    description: 'same offset applied to all keyframes',
    indexedKeyframes: {
      left: ['0px', '100px'],
      offset: 0.5,
    },
    sequencedKeyframes: [
      {left: '0px', offset: 0.5},
      {left: '100px', offset: 0.5},
    ],
  },
  {
    description: 'same easing applied to all keyframes',
    indexedKeyframes: {
      left: ['10px', '100px', '150px'],
      opacity: ['1', '0', '1'],
      easing: 'ease',
    },
    sequencedKeyframes: [
      {left: '10px', opacity: '1', easing: 'ease'},
      {left: '100px', opacity: '0', easing: 'ease'},
      {left: '150px', opacity: '1', easing: 'ease'},
    ],
  },
  {
    description: 'same composite applied to all keyframes',
    indexedKeyframes: {
      left: ['0px', '100px'],
      composite: 'add',
    },
    sequencedKeyframes: [
      {left: '0px', composite: 'add'},
      {left: '100px', composite: 'add'},
    ],
  },
];

gEquivalentSyntaxTests.forEach(function({description, indexedKeyframes, sequencedKeyframes}) {
  test(function(t) {
    assertEquivalentKeyframeSyntax(indexedKeyframes, sequencedKeyframes);
  }, 'Equivalent property indexed and sequenced keyframes: ' + description);
});

// FIXME: Test that non-enumerable properties are not accessed

// FIXME: Test that properties are accessed in ascending order by Unicode
//        codepoint
//        (There is an existing test for this in
//        keyframe-effect/constructor.html that should be moved here.)

</script>
